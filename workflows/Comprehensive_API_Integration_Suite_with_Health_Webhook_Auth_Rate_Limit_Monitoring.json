{
  "id": "3CHTe1GoIZtw7fYT",
  "meta": {
    "instanceId": "f31c8cf0f30c343fde4e229f596b53099ee0496367bfd39c53458e5afe95e91e"
  },
  "name": "API Integration Testing & Monitoring MCP Server",
  "tags": [],
  "nodes": [
    {
      "id": "5d8f6345-482c-4cdf-9574-7cf13802202e",
      "name": "MCP Server - API Monitor Entry",
      "type": "@n8n/n8n-nodes-langchain.mcpTrigger",
      "position": [
        -944,
        -576
      ],
      "webhookId": "55fbc57f-25f2-4c2c-b807-a7318498fa31",
      "parameters": {
        "path": "api-monitoring-server",
        "authentication": "bearerAuth"
      },
      "typeVersion": 2
    },
    {
      "id": "7f2db1a9-7586-4503-8c84-7d5cc0e99378",
      "name": "Analyze API Health",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        -1152,
        -256
      ],
      "parameters": {
        "source": "parameter",
        "description": "Analyzes API endpoint health including response times, status codes, SSL certificates, and detects anomalies using historical data patterns.",
        "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"api-health-monitor\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"test-api-endpoint\",\n      \"name\": \"Test API Endpoint\",\n      \"type\": \"nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"url\": \"={{ $json.endpoint_url }}\",\n        \"options\": {\n          \"response\": {\n            \"response\": {\n              \"responseFormat\": \"json\"\n            }\n          },\n          \"timeout\": 10000\n        }\n      }\n    },\n    {\n      \"id\": \"analyze-response\",\n      \"name\": \"Analyze Response\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const response = $input.first().json;\\nconst responseTime = response.response?.timings?.response || 0;\\nconst statusCode = response.response?.statusCode || 0;\\n\\nconst isHealthy = statusCode >= 200 && statusCode < 300;\\nconst healthStatus = !isHealthy ? 'CRITICAL' : responseTime > 2000 ? 'WARNING' : 'HEALTHY';\\n\\nreturn [{\\n  tool_name: 'analyze_api_health',\\n  timestamp: new Date().toISOString(),\\n  endpoint: $json.endpoint_url,\\n  health_status: healthStatus,\\n  metrics: {\\n    status_code: statusCode,\\n    response_time_ms: responseTime,\\n    is_healthy: isHealthy\\n  },\\n  recommendations: !isHealthy ? ['Check API endpoint immediately'] : ['API operating normally']\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Test API Endpoint\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Test API Endpoint\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
      },
      "typeVersion": 2.2
    },
    {
      "id": "4b83da51-ab52-4817-9aba-03ff307e74dd",
      "name": "Validate Webhook Reliability",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        -992,
        -256
      ],
      "parameters": {
        "source": "parameter",
        "description": "Tests webhook delivery reliability by sending test payloads and measuring success rates, response times, and retry behavior for webhook endpoints.\n\n",
        "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"webhook-reliability-monitor\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"test-webhook-delivery\",\n      \"name\": \"Test Webhook Delivery\",\n      \"type\": \"nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"url\": \"={{ $json.webhook_url }}\",\n        \"method\": \"POST\",\n        \"body\": {\n          \"mode\": \"json\",\n          \"jsonData\": \"={{ JSON.stringify({\\n  test_payload: true,\\n  timestamp: new Date().toISOString(),\\n  test_id: 'webhook_reliability_' + Date.now()\\n}) }}\"\n        },\n        \"options\": {\n          \"response\": {\n            \"response\": {\n              \"responseFormat\": \"json\"\n            }\n          },\n          \"timeout\": 15000,\n          \"retry\": {\n            \"enabled\": true,\n            \"maxRetries\": 3,\n            \"retryDelay\": 1000\n          }\n        }\n      }\n    },\n    {\n      \"id\": \"analyze-webhook-response\",\n      \"name\": \"Analyze Webhook Response\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const response = $input.first().json;\\nconst responseTime = response.response?.timings?.response || 0;\\nconst statusCode = response.response?.statusCode || 0;\\nconst retryCount = response.response?.retryCount || 0;\\n\\n// Determine webhook reliability\\nconst isSuccessful = statusCode >= 200 && statusCode < 300;\\nconst isReliable = isSuccessful && responseTime < 5000; // 5 second threshold\\nconst reliabilityStatus = !isSuccessful ? 'FAILED' : !isReliable ? 'SLOW' : 'RELIABLE';\\n\\n// Calculate success metrics\\nconst deliverySuccess = isSuccessful;\\nconst averageResponseTime = responseTime;\\nconst totalRetries = retryCount;\\n\\n// Generate reliability report\\nconst recommendations = [];\\nif (!isSuccessful) {\\n  recommendations.push('Check webhook endpoint configuration');\\n  recommendations.push('Verify webhook URL is accessible');\\n  recommendations.push('Check authentication requirements');\\n}\\nif (responseTime > 5000) {\\n  recommendations.push('Webhook response time is slow');\\n  recommendations.push('Consider optimizing webhook handler');\\n}\\nif (retryCount > 0) {\\n  recommendations.push(`Webhook required ${retryCount} retries`);\\n}\\nif (reliabilityStatus === 'RELIABLE') {\\n  recommendations.push('Webhook operating reliably');\\n}\\n\\nreturn [{\\n  tool_name: 'validate_webhook_reliability',\\n  timestamp: new Date().toISOString(),\\n  webhook_url: $json.webhook_url,\\n  reliability_status: reliabilityStatus,\\n  delivery_metrics: {\\n    success: deliverySuccess,\\n    status_code: statusCode,\\n    response_time_ms: responseTime,\\n    retry_count: totalRetries,\\n    delivery_rate: deliverySuccess ? 100 : 0\\n  },\\n  performance_analysis: {\\n    is_fast: responseTime < 2000,\\n    is_acceptable: responseTime < 5000,\\n    requires_optimization: responseTime > 5000\\n  },\\n  recommendations: recommendations,\\n  test_details: {\\n    test_payload_sent: true,\\n    test_timestamp: new Date().toISOString(),\\n    endpoint_reachable: statusCode !== 0\\n  }\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Test Webhook Delivery\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Test Webhook Delivery\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Webhook Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
      },
      "typeVersion": 2.2
    },
    {
      "id": "28ed2bf1-0101-4376-8f6c-e8b9b68d10ee",
      "name": "Monitor API Limits",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        -832,
        -256
      ],
      "parameters": {
        "source": "parameter",
        "description": "Monitors API rate limits by checking rate limit headers, calculating usage percentages and burn rates, predicting time to exhaustion, and alerting on approaching limits.",
        "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"api-limits-monitor\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"check-rate-limits\",\n      \"name\": \"Check Rate Limits\",\n      \"type\": \"nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"url\": \"={{ $json.endpoint_url }}\",\n        \"method\": \"GET\",\n        \"sendHeaders\": true,\n        \"headerParameters\": {\n          \"parameters\": [\n            {\n              \"name\": \"Authorization\",\n              \"value\": \"={{ $json.auth_type === 'bearer' ? 'Bearer ' + $json.auth_token : $json.auth_type === 'apikey' ? $json.auth_token : 'Basic ' + Buffer.from($json.auth_token).toString('base64') }}\"\n            }\n          ]\n        },\n        \"options\": {\n          \"response\": {\n            \"response\": {\n              \"responseFormat\": \"json\",\n              \"fullResponse\": true\n            }\n          },\n          \"timeout\": 10000\n        }\n      }\n    },\n    {\n      \"id\": \"analyze-rate-limits\",\n      \"name\": \"Analyze Rate Limits\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const response = $input.first().json;\\nconst headers = response.headers || {};\\nconst statusCode = response.statusCode || 0;\\n\\n// Extract rate limit headers (common variations)\\nconst rateLimitUsed = parseInt(headers['x-ratelimit-used'] || headers['x-rate-limit-used'] || headers['ratelimit-used'] || 0);\\nconst rateLimitLimit = parseInt(headers['x-ratelimit-limit'] || headers['x-rate-limit-limit'] || headers['ratelimit-limit'] || 0);\\nconst rateLimitReset = parseInt(headers['x-ratelimit-reset'] || headers['x-rate-limit-reset'] || headers['ratelimit-reset'] || 0);\\nconst rateLimitRemaining = parseInt(headers['x-ratelimit-remaining'] || headers['x-rate-limit-remaining'] || headers['ratelimit-remaining'] || (rateLimitLimit - rateLimitUsed));\\n\\n// Calculate metrics\\nconst usagePercentage = rateLimitLimit > 0 ? Math.round((rateLimitUsed / rateLimitLimit) * 100) : 0;\\nconst remainingPercentage = rateLimitLimit > 0 ? Math.round((rateLimitRemaining / rateLimitLimit) * 100) : 100;\\n\\n// Calculate time to reset\\nconst currentTime = Math.floor(Date.now() / 1000);\\nconst timeToReset = rateLimitReset > 0 ? rateLimitReset - currentTime : 0;\\nconst resetInMinutes = Math.max(0, Math.floor(timeToReset / 60));\\n\\n// Calculate burn rate (requests per minute)\\nconst timeWindow = 3600; // Assume 1 hour window\\nconst burnRate = rateLimitLimit > 0 && timeWindow > 0 ? Math.round((rateLimitUsed / timeWindow) * 60) : 0;\\n\\n// Predict time to exhaustion\\nconst requestsRemaining = rateLimitRemaining;\\nconst minutesToExhaustion = burnRate > 0 && requestsRemaining > 0 ? Math.floor(requestsRemaining / burnRate) : -1;\\n\\n// Determine alert status\\nlet alertStatus = 'NORMAL';\\nif (usagePercentage >= 90) {\\n  alertStatus = 'CRITICAL';\\n} else if (usagePercentage >= 75) {\\n  alertStatus = 'WARNING';\\n} else if (usagePercentage >= 50) {\\n  alertStatus = 'WATCH';\\n}\\n\\n// Generate recommendations\\nconst recommendations = [];\\nif (usagePercentage >= 90) {\\n  recommendations.push('URGENT: Rate limit nearly exhausted - reduce API calls immediately');\\n  recommendations.push('Implement request queuing or throttling');\\n} else if (usagePercentage >= 75) {\\n  recommendations.push('Rate limit usage is high - monitor closely');\\n} else if (usagePercentage >= 50) {\\n  recommendations.push('Rate limit usage is moderate - continue monitoring');\\n} else {\\n  recommendations.push('Rate limit usage is low - operating normally');\\n}\\n\\nif (minutesToExhaustion > 0 && minutesToExhaustion < 60) {\\n  recommendations.push(`Rate limit will be exhausted in approximately ${minutesToExhaustion} minutes`);\\n}\\n\\nif (timeToReset > 0) {\\n  recommendations.push(`Rate limit resets in ${resetInMinutes} minutes`);\\n}\\n\\nreturn [{\\n  tool_name: 'monitor_api_limits',\\n  timestamp: new Date().toISOString(),\\n  endpoint: $json.endpoint_url,\\n  limit_status: alertStatus,\\n  rate_limit_metrics: {\\n    used: rateLimitUsed,\\n    limit: rateLimitLimit,\\n    remaining: rateLimitRemaining,\\n    usage_percentage: usagePercentage,\\n    remaining_percentage: remainingPercentage\\n  },\\n  timing_analysis: {\\n    reset_timestamp: rateLimitReset,\\n    time_to_reset_minutes: resetInMinutes,\\n    burn_rate_per_minute: burnRate,\\n    estimated_exhaustion_minutes: minutesToExhaustion\\n  },\\n  recommendations: recommendations,\\n  requires_immediate_action: usagePercentage >= 90\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Check Rate Limits\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Check Rate Limits\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Rate Limits\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
      },
      "typeVersion": 2.2
    },
    {
      "id": "97d9cc34-44ab-48a9-88a6-4ea888cad3dd",
      "name": "Verify Authentication",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        -672,
        -256
      ],
      "parameters": {
        "source": "parameter",
        "description": "Tests different authentication methods (Bearer, API key, Basic auth), validates token expiration, checks authentication response codes, and monitors auth failure patterns.",
        "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"auth-verification-monitor\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"test-authentication\",\n      \"name\": \"Test Authentication\",\n      \"type\": \"nodes-base.httpRequest\",\n      \"typeVersion\": 4.2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"url\": \"={{ $json.endpoint_url }}\",\n        \"method\": \"GET\",\n        \"sendHeaders\": true,\n        \"headerParameters\": {\n          \"parameters\": [\n            {\n              \"name\": \"Authorization\",\n              \"value\": \"={{ $json.auth_type === 'bearer' ? 'Bearer ' + $json.auth_token : $json.auth_type === 'apikey' ? $json.auth_token : 'Basic ' + Buffer.from($json.auth_token).toString('base64') }}\"\n            }\n          ]\n        },\n        \"options\": {\n          \"response\": {\n            \"response\": {\n              \"responseFormat\": \"json\",\n              \"fullResponse\": true\n            }\n          },\n          \"timeout\": 10000,\n          \"retry\": {\n            \"enabled\": false\n          }\n        }\n      }\n    },\n    {\n      \"id\": \"analyze-auth-response\",\n      \"name\": \"Analyze Auth Response\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const response = $input.first().json;\\nconst statusCode = response.statusCode || 0;\\nconst headers = response.headers || {};\\nconst responseBody = response.body || {};\\nconst responseTime = response.response?.timings?.response || 0;\\n\\n// Determine authentication status\\nlet authStatus = 'UNKNOWN';\\nlet authValid = false;\\nlet tokenExpired = false;\\nlet insufficientPermissions = false;\\n\\nif (statusCode === 200 || statusCode === 201) {\\n  authStatus = 'VALID';\\n  authValid = true;\\n} else if (statusCode === 401) {\\n  authStatus = 'INVALID';\\n  // Check if it's token expiration\\n  const errorMessage = JSON.stringify(responseBody).toLowerCase();\\n  if (errorMessage.includes('expired') || errorMessage.includes('token') && errorMessage.includes('invalid')) {\\n    tokenExpired = true;\\n    authStatus = 'EXPIRED';\\n  }\\n} else if (statusCode === 403) {\\n  authStatus = 'INSUFFICIENT_PERMISSIONS';\\n  insufficientPermissions = true;\\n} else if (statusCode === 429) {\\n  authStatus = 'RATE_LIMITED';\\n} else if (statusCode >= 500) {\\n  authStatus = 'SERVER_ERROR';\\n} else {\\n  authStatus = 'FAILED';\\n}\\n\\n// Analyze auth method effectiveness\\nconst authMethod = $json.auth_type || 'unknown';\\nlet methodAnalysis = {\\n  type: authMethod,\\n  working: authValid,\\n  response_time_ms: responseTime\\n};\\n\\n// Check for auth-specific headers\\nconst authHeaders = {\\n  'www-authenticate': headers['www-authenticate'] || null,\\n  'authorization': headers['authorization'] ? 'present' : 'missing',\\n  'x-api-key': headers['x-api-key'] ? 'present' : 'missing'\\n};\\n\\n// Generate failure patterns analysis\\nconst failurePatterns = [];\\nif (statusCode === 401) {\\n  failurePatterns.push('Authentication credentials rejected');\\n  if (tokenExpired) {\\n    failurePatterns.push('Token appears to be expired');\\n  }\\n}\\nif (statusCode === 403) {\\n  failurePatterns.push('Insufficient permissions for this endpoint');\\n}\\nif (responseTime > 5000) {\\n  failurePatterns.push('Slow authentication response time');\\n}\\n\\n// Generate recommendations\\nconst recommendations = [];\\nif (authValid) {\\n  recommendations.push('Authentication is working correctly');\\n  if (responseTime > 2000) {\\n    recommendations.push('Consider monitoring auth response times');\\n  }\\n} else {\\n  if (tokenExpired) {\\n    recommendations.push('URGENT: Refresh or renew authentication token');\\n    recommendations.push('Implement automatic token refresh mechanism');\\n  } else if (insufficientPermissions) {\\n    recommendations.push('Check API permissions and scopes');\\n    recommendations.push('Verify account has required access levels');\\n  } else if (statusCode === 401) {\\n    recommendations.push('Verify authentication credentials are correct');\\n    recommendations.push('Check auth method matches API requirements');\\n  } else {\\n    recommendations.push('Check API endpoint and authentication method');\\n    recommendations.push('Verify network connectivity to auth server');\\n  }\\n}\\n\\nreturn [{\\n  tool_name: 'verify_authentication',\\n  timestamp: new Date().toISOString(),\\n  endpoint: $json.endpoint_url,\\n  auth_status: authStatus,\\n  authentication_results: {\\n    is_valid: authValid,\\n    status_code: statusCode,\\n    response_time_ms: responseTime,\\n    auth_method: authMethod,\\n    token_expired: tokenExpired,\\n    insufficient_permissions: insufficientPermissions\\n  },\\n  method_analysis: methodAnalysis,\\n  failure_patterns: failurePatterns,\\n  auth_headers_detected: authHeaders,\\n  recommendations: recommendations,\\n  requires_immediate_action: tokenExpired || (statusCode === 401 && !tokenExpired)\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Test Authentication\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Test Authentication\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Analyze Auth Response\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
      },
      "typeVersion": 2.2
    },
    {
      "id": "9436b97f-9cfa-448c-a5cb-920bc5b26cdd",
      "name": "Generate Client Report",
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "position": [
        -528,
        -256
      ],
      "parameters": {
        "source": "parameter",
        "description": "Aggregates monitoring data from other tools to create comprehensive client reports with executive summaries, performance metrics, and actionable recommendations.",
        "workflowJson": "{\n  \"meta\": {\n    \"instanceId\": \"client-report-generator\"\n  },\n  \"nodes\": [\n    {\n      \"id\": \"execute-workflow-trigger\",\n      \"name\": \"Execute Workflow Trigger\",\n      \"type\": \"nodes-base.executeWorkflowTrigger\",\n      \"typeVersion\": 1,\n      \"position\": [0, 0],\n      \"parameters\": {}\n    },\n    {\n      \"id\": \"aggregate-monitoring-data\",\n      \"name\": \"Aggregate Monitoring Data\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [200, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"// Get input data - could be from previous tool executions or provided data\\nconst inputData = $input.first().json;\\n\\n// Extract individual tool results if they exist\\nconst apiHealthData = inputData.api_health_data || {};\\nconst webhookData = inputData.webhook_data || {};\\nconst limitsData = inputData.limits_data || {};\\nconst authData = inputData.auth_data || {};\\n\\n// Or use the current input as a single tool result\\nconst toolData = inputData.tool_name ? inputData : {};\\n\\n// Initialize aggregated metrics\\nlet overallHealth = 'UNKNOWN';\\nlet criticalIssues = [];\\nlet warnings = [];\\nlet recommendations = [];\\nlet healthScore = 0;\\n\\n// Analyze API Health\\nif (apiHealthData.health_status || toolData.tool_name === 'analyze_api_health') {\\n  const healthStatus = apiHealthData.health_status || toolData.health_status;\\n  if (healthStatus === 'CRITICAL') {\\n    criticalIssues.push('API endpoint health is critical');\\n    healthScore += 0;\\n  } else if (healthStatus === 'WARNING') {\\n    warnings.push('API endpoint has performance issues');\\n    healthScore += 50;\\n  } else if (healthStatus === 'HEALTHY') {\\n    healthScore += 100;\\n  }\\n}\\n\\n// Analyze Webhook Reliability\\nif (webhookData.reliability_status || toolData.tool_name === 'validate_webhook_reliability') {\\n  const webhookStatus = webhookData.reliability_status || toolData.reliability_status;\\n  if (webhookStatus === 'FAILED') {\\n    criticalIssues.push('Webhook delivery is failing');\\n    healthScore += 0;\\n  } else if (webhookStatus === 'SLOW') {\\n    warnings.push('Webhook response times are slow');\\n    healthScore += 50;\\n  } else if (webhookStatus === 'RELIABLE') {\\n    healthScore += 100;\\n  }\\n}\\n\\n// Analyze Rate Limits\\nif (limitsData.limit_status || toolData.tool_name === 'monitor_api_limits') {\\n  const limitStatus = limitsData.limit_status || toolData.limit_status;\\n  if (limitStatus === 'CRITICAL') {\\n    criticalIssues.push('API rate limits nearly exhausted');\\n    healthScore += 0;\\n  } else if (limitStatus === 'WARNING') {\\n    warnings.push('API rate limit usage is high');\\n    healthScore += 50;\\n  } else if (limitStatus === 'WATCH') {\\n    warnings.push('API rate limit usage should be monitored');\\n    healthScore += 75;\\n  } else if (limitStatus === 'NORMAL') {\\n    healthScore += 100;\\n  }\\n}\\n\\n// Analyze Authentication\\nif (authData.auth_status || toolData.tool_name === 'verify_authentication') {\\n  const authStatus = authData.auth_status || toolData.auth_status;\\n  if (authStatus === 'INVALID' || authStatus === 'EXPIRED') {\\n    criticalIssues.push('Authentication is failing');\\n    healthScore += 0;\\n  } else if (authStatus === 'INSUFFICIENT_PERMISSIONS') {\\n    warnings.push('Authentication has insufficient permissions');\\n    healthScore += 25;\\n  } else if (authStatus === 'VALID') {\\n    healthScore += 100;\\n  }\\n}\\n\\n// Calculate overall health based on number of tools checked\\nconst toolsChecked = Math.max(1, Object.keys({apiHealthData, webhookData, limitsData, authData}).filter(key => \\n  eval(key) && Object.keys(eval(key)).length > 0\\n).length);\\n\\nconst averageScore = healthScore / toolsChecked;\\n\\nif (criticalIssues.length > 0) {\\n  overallHealth = 'CRITICAL';\\n} else if (warnings.length > 0) {\\n  overallHealth = 'WARNING';\\n} else if (averageScore >= 80) {\\n  overallHealth = 'HEALTHY';\\n} else {\\n  overallHealth = 'DEGRADED';\\n}\\n\\nreturn [{\\n  aggregated_data: {\\n    overall_health: overallHealth,\\n    health_score: Math.round(averageScore),\\n    critical_issues: criticalIssues,\\n    warnings: warnings,\\n    tools_monitored: toolsChecked,\\n    api_health: apiHealthData,\\n    webhook_reliability: webhookData,\\n    rate_limits: limitsData,\\n    authentication: authData,\\n    single_tool_data: toolData\\n  }\\n}];\"\n      }\n    },\n    {\n      \"id\": \"generate-client-report\",\n      \"name\": \"Generate Client Report\",\n      \"type\": \"nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [400, 0],\n      \"parameters\": {\n        \"language\": \"javascript\",\n        \"jsCode\": \"const data = $input.first().json.aggregated_data;\\nconst timestamp = new Date().toISOString();\\nconst reportDate = new Date().toLocaleDateString();\\n\\n// Generate Executive Summary\\nlet executiveSummary = '';\\nif (data.overall_health === 'CRITICAL') {\\n  executiveSummary = `URGENT: Your API integrations require immediate attention. ${data.critical_issues.length} critical issues detected that may impact service availability.`;\\n} else if (data.overall_health === 'WARNING') {\\n  executiveSummary = `Your API integrations are operational but showing signs of degradation. ${data.warnings.length} warnings require monitoring.`;\\n} else if (data.overall_health === 'HEALTHY') {\\n  executiveSummary = 'Your API integrations are performing well with no critical issues detected. Continue current monitoring practices.';\\n} else {\\n  executiveSummary = 'API integration health assessment completed. Review detailed findings below.';\\n}\\n\\n// Generate Performance Metrics Summary\\nconst performanceMetrics = {\\n  overall_health_score: `${data.health_score}/100`,\\n  system_status: data.overall_health,\\n  critical_issues_count: data.critical_issues.length,\\n  warnings_count: data.warnings.length,\\n  monitoring_coverage: `${data.tools_monitored} tools active`\\n};\\n\\n// Generate Detailed Findings\\nconst detailedFindings = [];\\n\\nif (data.api_health && Object.keys(data.api_health).length > 0) {\\n  detailedFindings.push({\\n    category: 'API Health',\\n    status: data.api_health.health_status || 'Unknown',\\n    metrics: data.api_health.metrics || {},\\n    key_finding: data.api_health.health_status === 'HEALTHY' ? 'API responding normally' : 'API performance issues detected'\\n  });\\n}\\n\\nif (data.webhook_reliability && Object.keys(data.webhook_reliability).length > 0) {\\n  detailedFindings.push({\\n    category: 'Webhook Reliability',\\n    status: data.webhook_reliability.reliability_status || 'Unknown',\\n    metrics: data.webhook_reliability.delivery_metrics || {},\\n    key_finding: data.webhook_reliability.reliability_status === 'RELIABLE' ? 'Webhooks delivering successfully' : 'Webhook delivery issues detected'\\n  });\\n}\\n\\nif (data.rate_limits && Object.keys(data.rate_limits).length > 0) {\\n  detailedFindings.push({\\n    category: 'Rate Limits',\\n    status: data.rate_limits.limit_status || 'Unknown',\\n    metrics: data.rate_limits.rate_limit_metrics || {},\\n    key_finding: data.rate_limits.limit_status === 'NORMAL' ? 'Rate limit usage is normal' : 'Rate limit concerns detected'\\n  });\\n}\\n\\nif (data.authentication && Object.keys(data.authentication).length > 0) {\\n  detailedFindings.push({\\n    category: 'Authentication',\\n    status: data.authentication.auth_status || 'Unknown',\\n    metrics: data.authentication.authentication_results || {},\\n    key_finding: data.authentication.auth_status === 'VALID' ? 'Authentication working correctly' : 'Authentication issues detected'\\n  });\\n}\\n\\n// Generate Prioritized Recommendations\\nconst prioritizedRecommendations = [];\\n\\n// Critical recommendations first\\nif (data.critical_issues.length > 0) {\\n  prioritizedRecommendations.push({\\n    priority: 'URGENT',\\n    category: 'Critical Issues',\\n    actions: data.critical_issues.map(issue => `Address: ${issue}`)\\n  });\\n}\\n\\n// Warning recommendations\\nif (data.warnings.length > 0) {\\n  prioritizedRecommendations.push({\\n    priority: 'HIGH',\\n    category: 'Performance Optimization',\\n    actions: data.warnings.map(warning => `Monitor: ${warning}`)\\n  });\\n}\\n\\n// General recommendations\\nif (data.overall_health === 'HEALTHY') {\\n  prioritizedRecommendations.push({\\n    priority: 'MEDIUM',\\n    category: 'Maintenance',\\n    actions: [\\n      'Continue regular monitoring schedule',\\n      'Review performance trends monthly',\\n      'Maintain current monitoring configuration'\\n    ]\\n  });\\n}\\n\\n// Next Steps\\nconst nextSteps = [];\\nif (data.critical_issues.length > 0) {\\n  nextSteps.push('1. Address critical issues immediately (within 24 hours)');\\n  nextSteps.push('2. Implement monitoring alerts for critical thresholds');\\n  nextSteps.push('3. Schedule follow-up assessment in 48 hours');\\n} else if (data.warnings.length > 0) {\\n  nextSteps.push('1. Review warning conditions (within 7 days)');\\n  nextSteps.push('2. Optimize performance where possible');\\n  nextSteps.push('3. Schedule follow-up assessment in 2 weeks');\\n} else {\\n  nextSteps.push('1. Continue current monitoring schedule');\\n  nextSteps.push('2. Review monthly performance trends');\\n  nextSteps.push('3. Next comprehensive assessment in 30 days');\\n}\\n\\nreturn [{\\n  tool_name: 'generate_client_report',\\n  timestamp: timestamp,\\n  report_date: reportDate,\\n  report_summary: {\\n    overall_status: data.overall_health,\\n    health_score: data.health_score,\\n    requires_attention: data.critical_issues.length > 0 || data.warnings.length > 0\\n  },\\n  executive_summary: executiveSummary,\\n  performance_metrics: performanceMetrics,\\n  detailed_findings: detailedFindings,\\n  prioritized_recommendations: prioritizedRecommendations,\\n  next_steps: nextSteps,\\n  report_metadata: {\\n    generated_by: 'API Integration Monitoring System',\\n    report_type: 'Comprehensive Integration Health Assessment',\\n    monitoring_period: '24 hours',\\n    tools_analyzed: data.tools_monitored\\n  }\\n}];\"\n      }\n    }\n  ],\n  \"connections\": {\n    \"Execute Workflow Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Aggregate Monitoring Data\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Aggregate Monitoring Data\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Generate Client Report\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  }\n}\n\n\n\n\n\n\n\n\n"
      },
      "typeVersion": 2.2
    },
    {
      "id": "8dad92eb-4466-47ec-ba3a-e9a18b64aafb",
      "name": "Sticky Note1",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1392,
        -336
      ],
      "parameters": {
        "color": 5,
        "width": 1056,
        "height": 640,
        "content": "## \ud83d\udd27 Available MCP Tools\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**Analyze API Health**\n\ud83d\udccb Tests endpoint response times, status codes, and overall health\n\ud83c\udfaf Use: Check if APIs are responding normally\n\n**Validate Webhook Reliability** \n\ud83d\udccb Tests webhook delivery with retry analysis\n\ud83c\udfaf Use: Verify webhook endpoints are receiving data properly\n\n**Monitor API Limits**\n\ud83d\udccb Checks rate limit headers and usage percentages  \n\ud83c\udfaf Use: Prevent rate limit exhaustion and plan usage\n\n**Verify Authentication**\n\ud83d\udccb Tests Bearer, API key, and Basic auth methods\n\ud83c\udfaf Use: Ensure API credentials are working correctly\n\n**Generate Client Report**\n\ud83d\udccb Creates comprehensive reports with executive summaries\n\ud83c\udfaf Use: Share API health status with stakeholders"
      },
      "typeVersion": 1
    },
    {
      "id": "24e39a69-90c9-4365-b994-093ffbd23fc7",
      "name": "Sticky Note2",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1008,
        -720
      ],
      "parameters": {
        "width": 422,
        "height": 304,
        "content": "\u2705 **Step 1: Configure MCP Server Access**\n- **MCP Server - API Monitor Entry** node: \n  - Path is pre-configured as \"api-monitoring-server\"\n  - Set up Bearer Auth credentials for secure access\n  - Generate a secure token for client connections"
      },
      "typeVersion": 1
    },
    {
      "id": "fbf995c5-8448-4e37-85ac-2fc0014aef17",
      "name": "Sticky Note3",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -512,
        -1360
      ],
      "parameters": {
        "color": 4,
        "width": 432,
        "height": 944,
        "content": "\ud83d\udcca How to Use MCP Tools\n\n**Quick Test (Real Working URLs - Test These First!):**\nThese are verified testing endpoints that work immediately:\n\n\"Check the health of https://jsonplaceholder.typicode.com/posts/1\"\n\u2192 Free testing API, always returns 200 OK, no setup needed\n\n\"Test webhook delivery to https://httpbin.org/post\"\n\u2192 Instantly accepts POST data and shows what was received\n\n\"Monitor rate limits for https://api.github.com/rate_limit\"\n\u2192 Shows real rate limit headers, works without authentication\n\n\"Verify authentication with https://httpbin.org/basic-auth/test/test\"\n\u2192 Test credentials: username \"test\", password \"test\"\n\n**For Your Production APIs:**\nOnce you've tested the tools, replace with your real endpoints:\n- Your API health check: https://your-api.com/health\n- Your webhook receiver: https://your-webhook.com/receive\n- Your authenticated endpoints with real credentials\n\n**Authentication Examples:**\n- Bearer: {\"auth_type\": \"bearer\", \"auth_token\": \"your_github_token\"}\n- API Key: {\"auth_type\": \"apikey\", \"auth_token\": \"your_api_key\"}  \n- Basic: {\"auth_type\": \"basic\", \"auth_token\": \"test:test\"}\n\n**What Each Test Does:**\n\u2705 JSONPlaceholder - Confirms API connectivity and response parsing\n\u2705 httpbin.org/post - Validates webhook delivery and payload handling  \n\u2705 GitHub rate_limit - Demonstrates real rate limit monitoring\n\u2705 httpbin basic-auth - Tests authentication validation flows\n\nStart with these test URLs to see the tools working, then switch to your own APIs!"
      },
      "typeVersion": 1
    },
    {
      "id": "71cfdd67-ac53-4042-a1a7-f86c1a21af09",
      "name": "Sticky Note4",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1600,
        -896
      ],
      "parameters": {
        "color": 6,
        "width": 512,
        "height": 480,
        "content": "\ud83d\udee0\ufe0f API Integration Testing & Monitoring MCP Server\n\nThis workflow creates a comprehensive MCP server that provides 5 specialized API monitoring tools accessible to external MCP clients like Claude Desktop or custom applications.\n\n\u2705 **Step 2: Deploy & Test Immediately**\n- Activate the workflow in your n8n instance\n- Copy the generated MCP server endpoint URL\n- **Quick Test**: Use the test URLs in the \"How to Use\" note to verify everything works\n- Then connect your real APIs and credentials\n\n\u2705 **Step 3: Connect MCP Client**\n- Configure Claude Desktop or your MCP client with the server endpoint\n- Add authentication token to client configuration\n- Test connection to verify all 5 tools are available\n\n\u2705 **Step 4: Start Monitoring APIs**\n- Begin with test URLs to see tools in action\n- Gradually replace with your production endpoints\n- Generate comprehensive reports for stakeholders"
      },
      "typeVersion": 1
    }
  ],
  "active": false,
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "ba3b09df-b03e-4e24-83cf-2f27250036cf",
  "connections": {
    "Analyze API Health": {
      "ai_tool": [
        [
          {
            "node": "MCP Server - API Monitor Entry",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Monitor API Limits": {
      "ai_tool": [
        [
          {
            "node": "MCP Server - API Monitor Entry",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Verify Authentication": {
      "ai_tool": [
        [
          {
            "node": "MCP Server - API Monitor Entry",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Generate Client Report": {
      "ai_tool": [
        [
          {
            "node": "MCP Server - API Monitor Entry",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Validate Webhook Reliability": {
      "ai_tool": [
        [
          {
            "node": "MCP Server - API Monitor Entry",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "_metadata": {
    "name": "Comprehensive API Integration Suite with Health, Webhook, Auth & Rate Limit Monitoring",
    "used_count": 1,
    "popularity_score": 25,
    "source_url": "https://n8n.io/workflows/6607",
    "scraped_at": "2025-08-17 19:11:16"
  }
}